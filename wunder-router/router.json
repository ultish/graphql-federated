{
  "engineConfig": {
    "defaultFlushInterval": "500",
    "datasourceConfigurations": [
      {
        "kind": "GRAPHQL",
        "rootNodes": [
          {
            "typeName": "Mutation",
            "fieldNames": [
              "createChargeCode",
              "createQuickAction",
              "createTrackedDay",
              "createTrackedTask",
              "createUser",
              "deleteChargeCode",
              "deleteQuickAction",
              "deleteTrackedDay",
              "deleteTrackedTask",
              "deleteUser",
              "updateChargeCode",
              "updateQuickAction",
              "updateTrackedDay",
              "updateTrackedTask",
              "updateUser"
            ]
          },
          {
            "typeName": "Query",
            "fieldNames": [
              "chargeCodes",
              "quickAction",
              "quickActions",
              "timeChargeTotals",
              "timeCharges",
              "trackedDay",
              "trackedDaysForMonthYear",
              "trackedDaysPaginated",
              "trackedTask",
              "trackedTasks",
              "users"
            ]
          },
          {
            "typeName": "Subscription",
            "fieldNames": [
              "timeChargeTotalsChanged",
              "trackedDayChanged"
            ]
          }
        ],
        "childNodes": [
          {
            "typeName": "ChargeCode",
            "fieldNames": [
              "code",
              "description",
              "expired",
              "group",
              "id",
              "name",
              "sortOrder"
            ]
          },
          {
            "typeName": "PageInfo",
            "fieldNames": [
              "endCursor",
              "hasNextPage",
              "hasPreviousPage",
              "startCursor"
            ]
          },
          {
            "typeName": "QuickAction",
            "fieldNames": [
              "chargeCodes",
              "description",
              "id",
              "name",
              "timeSlots"
            ]
          },
          {
            "typeName": "TimeCharge",
            "fieldNames": [
              "chargeCode",
              "chargeCodeAppearance",
              "id",
              "timeSlot",
              "totalChargeCodesForSlot",
              "trackedDay"
            ]
          },
          {
            "typeName": "TimeChargeTotal",
            "fieldNames": [
              "chargeCode",
              "id",
              "trackedDay",
              "user",
              "value"
            ]
          },
          {
            "typeName": "TrackedDay",
            "fieldNames": [
              "date",
              "id",
              "mode",
              "timeChargeTotals",
              "timeCharges",
              "trackedTasks",
              "user",
              "week",
              "year"
            ]
          },
          {
            "typeName": "TrackedDayConnection",
            "fieldNames": [
              "edges",
              "pageInfo"
            ]
          },
          {
            "typeName": "TrackedDayEdge",
            "fieldNames": [
              "cursor",
              "node"
            ]
          },
          {
            "typeName": "TrackedTask",
            "fieldNames": [
              "chargeCodes",
              "id",
              "notes",
              "timeSlots",
              "trackedDay"
            ]
          },
          {
            "typeName": "User",
            "fieldNames": [
              "id",
              "trackedDays",
              "username"
            ]
          }
        ],
        "overrideFieldPathFromAlias": true,
        "customGraphql": {
          "fetch": {
            "url": {
              "staticVariableContent": "http://localhost/graphql"
            },
            "method": "POST",
            "body": {},
            "baseUrl": {},
            "path": {}
          },
          "subscription": {
            "enabled": true,
            "url": {
              "staticVariableContent": "http://localhost/subscriptions"
            },
            "protocol": "GRAPHQL_SUBSCRIPTION_PROTOCOL_WS",
            "websocketSubprotocol": "GRAPHQL_WEBSOCKET_SUBPROTOCOL_TRANSPORT_WS"
          },
          "federation": {
            "enabled": true,
            "serviceSdl": "schema {\n  query: Query\n  mutation: Mutation\n  subscription: Subscription\n}\n\ntype ChargeCode {\n  code: String!\n  description: String\n  expired: Boolean!\n  group: String\n  id: ID!\n  name: String!\n  sortOrder: Int\n}\n\ntype Mutation {\n  createChargeCode(code: String!, description: String, expired: Boolean = false, group: String, name: String!, sortOrder: Int): ChargeCode\n  createQuickAction(chargeCodeIds: [ID!], description: String, name: String!, timeSlots: [Int!]): QuickAction!\n  createTrackedDay(date: Float!, mode: String): TrackedDay\n  createTrackedTask(chargeCodeIds: [ID!], notes: String, timeSlots: [Int!], trackedDayId: ID!): TrackedTask!\n  createUser(password: String!, username: String!): User\n  deleteChargeCode(id: ID!): ID\n  deleteQuickAction(id: ID!): ID\n  deleteTrackedDay(id: ID!): ID\n  deleteTrackedTask(id: ID): ID\n  deleteUser(username: String!): ID\n  updateChargeCode(code: String, description: String, expired: Boolean, group: String, id: ID!, name: String, sortOrder: Int): ChargeCode\n  updateQuickAction(chargeCodeIds: [ID!], description: String, id: ID!, name: String, timeSlots: [Int!]): QuickAction!\n  updateTrackedDay(id: ID!, mode: DayMode, trackedTaskIds: [String!]): TrackedDay\n  updateTrackedTask(chargeCodeIds: [ID!], id: ID!, notes: String, timeSlots: [Int!]): TrackedTask!\n  updateUser(trackedDayIds: [String], userId: ID!): User\n}\n\ntype PageInfo {\n  endCursor: String\n  hasNextPage: Boolean!\n  hasPreviousPage: Boolean!\n  startCursor: String\n}\n\ntype Query {\n  chargeCodes(code: String, description: String, expired: Boolean, ids: [ID!], name: String): [ChargeCode!]\n  quickAction(id: ID!): QuickAction\n  quickActions(ids: [ID!]): [QuickAction!]\n  timeChargeTotals(weekOfYear: WeekOfYear): [TimeChargeTotal!]\n  timeCharges(chargeCodeId: ID, timeSlot: Int, trackedDayId: String): [TimeCharge!]\n  trackedDay(id: ID): TrackedDay\n  trackedDaysForMonthYear(month: Int, year: Int): [TrackedDay!]\n  trackedDaysPaginated(after: String, first: Int): TrackedDayConnection\n  trackedTask(trackedTaskId: ID!): TrackedTask\n  trackedTasks(trackedDayId: ID): [TrackedTask!]\n  users(username: String): [User!]\n}\n\ntype QuickAction {\n  chargeCodes: [ChargeCode!]\n  description: String\n  id: ID!\n  name: String!\n  timeSlots: [Int!]\n}\n\ntype Subscription {\n  timeChargeTotalsChanged: TimeChargeTotal\n  trackedDayChanged(month: Int, year: Int): TrackedDay\n}\n\n\"\"\"\n    updateTimeCharge(\n        id: ID!,\n        chargeCodeAppearance: Int,\n        totalChargeCodesForSlot: Int\n    ): TimeCharge!\n}\n\"\"\"\ntype TimeCharge {\n  chargeCode: ChargeCode\n  \"The number of times this charge code appears at this timeslot\"\n  chargeCodeAppearance: Int\n  id: ID!\n  timeSlot: Int\n  \"The number of chargecodes that appear across all tracked tasks at this timeslot\"\n  totalChargeCodesForSlot: Int\n  trackedDay: TrackedDay\n}\n\n\"This represents a single ChargeCode for a Tracked Day and the value for the timesheet\"\ntype TimeChargeTotal {\n  chargeCode: ChargeCode\n  id: ID!\n  trackedDay: TrackedDay\n  user: User\n  value: Float\n}\n\n\" each tracked day will have a max of 240 timeslots (if you work 24hrs!)\"\ntype TrackedDay {\n  date: Float!\n  id: ID!\n  mode: DayMode!\n  timeChargeTotals: [TimeChargeTotal!]\n  timeCharges: [TimeCharge!]\n  trackedTasks: [TrackedTask!]\n  user: User\n  week: Int!\n  year: Int!\n}\n\n\"\"\"\n the @connection directive is meant to work but it clashes with dgs-codegen plugin (not supported yet, but there's\n  an untouched PR...). For now, implementing the types manually here\n\"\"\"\ntype TrackedDayConnection {\n  edges: [TrackedDayEdge!]\n  pageInfo: PageInfo!\n}\n\ntype TrackedDayEdge {\n  cursor: String!\n  node: TrackedDay\n}\n\ntype TrackedTask {\n  chargeCodes: [ChargeCode!]\n  id: ID!\n  notes: String\n  timeSlots: [Int!]\n  trackedDay: TrackedDay\n}\n\ntype User {\n  id: ID!\n  trackedDays: [TrackedDay!]\n  username: String!\n}\n\nenum DayMode {\n  HOL_ANNUAL\n  HOL_PERSONAL\n  HOL_PUBLIC\n  HOL_RDO\n  NORMAL\n}\n\nenum ErrorDetail {\n  \"\"\"\n  The deadline expired before the operation could complete.\n  \n  For operations that change the state of the system, this error\n  may be returned even if the operation has completed successfully.\n  For example, a successful response from a server could have been\n  delayed long enough for the deadline to expire.\n  \n  HTTP Mapping: 504 Gateway Timeout\n  Error Type: UNAVAILABLE\n  \"\"\"\n  DEADLINE_EXCEEDED\n  \"\"\"\n  The server detected that the client is exhibiting a behavior that\n  might be generating excessive load.\n  \n  HTTP Mapping: 429 Too Many Requests or 420 Enhance Your Calm\n  Error Type: UNAVAILABLE\n  \"\"\"\n  ENHANCE_YOUR_CALM\n  \"\"\"\n  The requested field is not found in the schema.\n  \n  This differs from `NOT_FOUND` in that `NOT_FOUND` should be used when a\n  query is valid, but is unable to return a result (if, for example, a\n  specific video id doesn't exist). `FIELD_NOT_FOUND` is intended to be\n  returned by the server to signify that the requested field is not known to exist.\n  This may be returned in lieu of failing the entire query.\n  See also `PERMISSION_DENIED` for cases where the\n  requested field is invalid only for the given user or class of users.\n  \n  HTTP Mapping: 404 Not Found\n  Error Type: BAD_REQUEST\n  \"\"\"\n  FIELD_NOT_FOUND\n  \"\"\"\n  The client specified an invalid argument.\n  \n  Note that this differs from `FAILED_PRECONDITION`.\n  `INVALID_ARGUMENT` indicates arguments that are problematic\n  regardless of the state of the system (e.g., a malformed file name).\n  \n  HTTP Mapping: 400 Bad Request\n  Error Type: BAD_REQUEST\n  \"\"\"\n  INVALID_ARGUMENT\n  \"\"\"\n  The provided cursor is not valid.\n  \n  The most common usage for this error is when a client is paginating\n  through a list that uses stateful cursors. In that case, the provided\n  cursor may be expired.\n  \n  HTTP Mapping: 404 Not Found\n  Error Type: NOT_FOUND\n  \"\"\"\n  INVALID_CURSOR\n  \"\"\"\n  Unable to perform operation because a required resource is missing.\n  \n  Example: Client is attempting to refresh a list, but the specified\n  list is expired. This requires an action by the client to get a new list.\n  \n  If the user is simply trying GET a resource that is not found,\n  use the NOT_FOUND error type. FAILED_PRECONDITION.MISSING_RESOURCE\n  is to be used particularly when the user is performing an operation\n  that requires a particular resource to exist.\n  \n  HTTP Mapping: 400 Bad Request or 500 Internal Server Error\n  Error Type: FAILED_PRECONDITION\n  \"\"\"\n  MISSING_RESOURCE\n  \"\"\"\n  Service Error.\n  \n  There is a problem with an upstream service.\n  \n  This may be returned if a gateway receives an unknown error from a service\n  or if a service is unreachable.\n  If a request times out which waiting on a response from a service,\n  `DEADLINE_EXCEEDED` may be returned instead.\n  If a service returns a more specific error Type, the specific error Type may\n  be returned instead.\n  \n  HTTP Mapping: 502 Bad Gateway\n  Error Type: UNAVAILABLE\n  \"\"\"\n  SERVICE_ERROR\n  \"\"\"\n  Request failed due to network errors.\n  \n  HTTP Mapping: 503 Unavailable\n  Error Type: UNAVAILABLE\n  \"\"\"\n  TCP_FAILURE\n  \"\"\"\n  Request throttled based on server concurrency limits.\n  \n  HTTP Mapping: 503 Unavailable\n  Error Type: UNAVAILABLE\n  \"\"\"\n  THROTTLED_CONCURRENCY\n  \"\"\"\n  Request throttled based on server CPU limits\n  \n  HTTP Mapping: 503 Unavailable.\n  Error Type: UNAVAILABLE\n  \"\"\"\n  THROTTLED_CPU\n  \"\"\"\n  The operation is not implemented or is not currently supported/enabled.\n  \n  HTTP Mapping: 501 Not Implemented\n  Error Type: BAD_REQUEST\n  \"\"\"\n  UNIMPLEMENTED\n  \"\"\"\n  Unknown error.\n  \n  This error should only be returned when no other error detail applies.\n  If a client sees an unknown errorDetail, it will be interpreted as UNKNOWN.\n  \n  HTTP Mapping: 500 Internal Server Error\n  \"\"\"\n  UNKNOWN\n}\n\nenum ErrorType {\n  \"\"\"\n  Bad Request.\n  \n  There is a problem with the request.\n  Retrying the same request is not likely to succeed.\n  An example would be a query or argument that cannot be deserialized.\n  \n  HTTP Mapping: 400 Bad Request\n  \"\"\"\n  BAD_REQUEST\n  \"\"\"\n  The operation was rejected because the system is not in a state\n  required for the operation's execution.  For example, the directory\n  to be deleted is non-empty, an rmdir operation is applied to\n  a non-directory, etc.\n  \n  Service implementers can use the following guidelines to decide\n  between `FAILED_PRECONDITION` and `UNAVAILABLE`:\n  \n  - Use `UNAVAILABLE` if the client can retry just the failing call.\n  - Use `FAILED_PRECONDITION` if the client should not retry until\n  the system state has been explicitly fixed.  E.g., if an \"rmdir\"\n       fails because the directory is non-empty, `FAILED_PRECONDITION`\n  should be returned since the client should not retry unless\n  the files are deleted from the directory.\n  \n  HTTP Mapping: 400 Bad Request or 500 Internal Server Error\n  \"\"\"\n  FAILED_PRECONDITION\n  \"\"\"\n  Internal error.\n  \n  An unexpected internal error was encountered. This means that some\n  invariants expected by the underlying system have been broken.\n  This error code is reserved for serious errors.\n  \n  HTTP Mapping: 500 Internal Server Error\n  \"\"\"\n  INTERNAL\n  \"\"\"\n  The requested entity was not found.\n  \n  This could apply to a resource that has never existed (e.g. bad resource id),\n  or a resource that no longer exists (e.g. cache expired.)\n  \n  Note to server developers: if a request is denied for an entire class\n  of users, such as gradual feature rollout or undocumented allowlist,\n  `NOT_FOUND` may be used. If a request is denied for some users within\n  a class of users, such as user-based access control, `PERMISSION_DENIED`\n  must be used.\n  \n  HTTP Mapping: 404 Not Found\n  \"\"\"\n  NOT_FOUND\n  \"\"\"\n  The caller does not have permission to execute the specified\n  operation.\n  \n  `PERMISSION_DENIED` must not be used for rejections\n  caused by exhausting some resource or quota.\n  `PERMISSION_DENIED` must not be used if the caller\n  cannot be identified (use `UNAUTHENTICATED`\n  instead for those errors).\n  \n  This error Type does not imply the\n  request is valid or the requested entity exists or satisfies\n  other pre-conditions.\n  \n  HTTP Mapping: 403 Forbidden\n  \"\"\"\n  PERMISSION_DENIED\n  \"\"\"\n  The request does not have valid authentication credentials.\n  \n  This is intended to be returned only for routes that require\n  authentication.\n  \n  HTTP Mapping: 401 Unauthorized\n  \"\"\"\n  UNAUTHENTICATED\n  \"\"\"\n  Currently Unavailable.\n  \n  The service is currently unavailable.  This is most likely a\n  transient condition, which can be corrected by retrying with\n  a backoff.\n  \n  HTTP Mapping: 503 Unavailable\n  \"\"\"\n  UNAVAILABLE\n  \"\"\"\n  Unknown error.\n  \n  For example, this error may be returned when\n  an error code received from another address space belongs to\n  an error space that is not known in this address space.  Also\n  errors raised by APIs that do not return enough error information\n  may be converted to this error.\n  \n  If a client sees an unknown errorType, it will be interpreted as UNKNOWN.\n  Unknown errors MUST NOT trigger any special behavior. These MAY be treated\n  by an implementation as being equivalent to INTERNAL.\n  \n  When possible, a more specific error should be provided.\n  \n  HTTP Mapping: 520 Unknown Error\n  \"\"\"\n  UNKNOWN\n}\n\ninput WeekOfYear {\n  week: Int\n  year: Int!\n}"
          },
          "upstreamSchema": {
            "key": "ea41d894b5b56061991f524eb9061a0139c0f700"
          }
        },
        "requestTimeoutSeconds": "10",
        "id": "0"
      }
    ],
    "fieldConfigurations": [
      {
        "typeName": "Mutation",
        "fieldName": "createChargeCode",
        "argumentsConfiguration": [
          {
            "name": "code",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "description",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "expired",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "group",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "name",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "sortOrder",
            "sourceType": "FIELD_ARGUMENT"
          }
        ]
      },
      {
        "typeName": "Mutation",
        "fieldName": "createQuickAction",
        "argumentsConfiguration": [
          {
            "name": "chargeCodeIds",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "description",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "name",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "timeSlots",
            "sourceType": "FIELD_ARGUMENT"
          }
        ]
      },
      {
        "typeName": "Mutation",
        "fieldName": "createTrackedDay",
        "argumentsConfiguration": [
          {
            "name": "date",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "mode",
            "sourceType": "FIELD_ARGUMENT"
          }
        ]
      },
      {
        "typeName": "Mutation",
        "fieldName": "createTrackedTask",
        "argumentsConfiguration": [
          {
            "name": "chargeCodeIds",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "notes",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "timeSlots",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "trackedDayId",
            "sourceType": "FIELD_ARGUMENT"
          }
        ]
      },
      {
        "typeName": "Mutation",
        "fieldName": "createUser",
        "argumentsConfiguration": [
          {
            "name": "password",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "username",
            "sourceType": "FIELD_ARGUMENT"
          }
        ]
      },
      {
        "typeName": "Mutation",
        "fieldName": "deleteChargeCode",
        "argumentsConfiguration": [
          {
            "name": "id",
            "sourceType": "FIELD_ARGUMENT"
          }
        ]
      },
      {
        "typeName": "Mutation",
        "fieldName": "deleteQuickAction",
        "argumentsConfiguration": [
          {
            "name": "id",
            "sourceType": "FIELD_ARGUMENT"
          }
        ]
      },
      {
        "typeName": "Mutation",
        "fieldName": "deleteTrackedDay",
        "argumentsConfiguration": [
          {
            "name": "id",
            "sourceType": "FIELD_ARGUMENT"
          }
        ]
      },
      {
        "typeName": "Mutation",
        "fieldName": "deleteTrackedTask",
        "argumentsConfiguration": [
          {
            "name": "id",
            "sourceType": "FIELD_ARGUMENT"
          }
        ]
      },
      {
        "typeName": "Mutation",
        "fieldName": "deleteUser",
        "argumentsConfiguration": [
          {
            "name": "username",
            "sourceType": "FIELD_ARGUMENT"
          }
        ]
      },
      {
        "typeName": "Mutation",
        "fieldName": "updateChargeCode",
        "argumentsConfiguration": [
          {
            "name": "code",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "description",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "expired",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "group",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "id",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "name",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "sortOrder",
            "sourceType": "FIELD_ARGUMENT"
          }
        ]
      },
      {
        "typeName": "Mutation",
        "fieldName": "updateQuickAction",
        "argumentsConfiguration": [
          {
            "name": "chargeCodeIds",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "description",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "id",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "name",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "timeSlots",
            "sourceType": "FIELD_ARGUMENT"
          }
        ]
      },
      {
        "typeName": "Mutation",
        "fieldName": "updateTrackedDay",
        "argumentsConfiguration": [
          {
            "name": "id",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "mode",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "trackedTaskIds",
            "sourceType": "FIELD_ARGUMENT"
          }
        ]
      },
      {
        "typeName": "Mutation",
        "fieldName": "updateTrackedTask",
        "argumentsConfiguration": [
          {
            "name": "chargeCodeIds",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "id",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "notes",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "timeSlots",
            "sourceType": "FIELD_ARGUMENT"
          }
        ]
      },
      {
        "typeName": "Mutation",
        "fieldName": "updateUser",
        "argumentsConfiguration": [
          {
            "name": "trackedDayIds",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "userId",
            "sourceType": "FIELD_ARGUMENT"
          }
        ]
      },
      {
        "typeName": "Query",
        "fieldName": "chargeCodes",
        "argumentsConfiguration": [
          {
            "name": "code",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "description",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "expired",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "ids",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "name",
            "sourceType": "FIELD_ARGUMENT"
          }
        ]
      },
      {
        "typeName": "Query",
        "fieldName": "quickAction",
        "argumentsConfiguration": [
          {
            "name": "id",
            "sourceType": "FIELD_ARGUMENT"
          }
        ]
      },
      {
        "typeName": "Query",
        "fieldName": "quickActions",
        "argumentsConfiguration": [
          {
            "name": "ids",
            "sourceType": "FIELD_ARGUMENT"
          }
        ]
      },
      {
        "typeName": "Query",
        "fieldName": "timeChargeTotals",
        "argumentsConfiguration": [
          {
            "name": "weekOfYear",
            "sourceType": "FIELD_ARGUMENT"
          }
        ]
      },
      {
        "typeName": "Query",
        "fieldName": "timeCharges",
        "argumentsConfiguration": [
          {
            "name": "chargeCodeId",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "timeSlot",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "trackedDayId",
            "sourceType": "FIELD_ARGUMENT"
          }
        ]
      },
      {
        "typeName": "Query",
        "fieldName": "trackedDay",
        "argumentsConfiguration": [
          {
            "name": "id",
            "sourceType": "FIELD_ARGUMENT"
          }
        ]
      },
      {
        "typeName": "Query",
        "fieldName": "trackedDaysForMonthYear",
        "argumentsConfiguration": [
          {
            "name": "month",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "year",
            "sourceType": "FIELD_ARGUMENT"
          }
        ]
      },
      {
        "typeName": "Query",
        "fieldName": "trackedDaysPaginated",
        "argumentsConfiguration": [
          {
            "name": "after",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "first",
            "sourceType": "FIELD_ARGUMENT"
          }
        ]
      },
      {
        "typeName": "Query",
        "fieldName": "trackedTask",
        "argumentsConfiguration": [
          {
            "name": "trackedTaskId",
            "sourceType": "FIELD_ARGUMENT"
          }
        ]
      },
      {
        "typeName": "Query",
        "fieldName": "trackedTasks",
        "argumentsConfiguration": [
          {
            "name": "trackedDayId",
            "sourceType": "FIELD_ARGUMENT"
          }
        ]
      },
      {
        "typeName": "Query",
        "fieldName": "users",
        "argumentsConfiguration": [
          {
            "name": "username",
            "sourceType": "FIELD_ARGUMENT"
          }
        ]
      },
      {
        "typeName": "Subscription",
        "fieldName": "trackedDayChanged",
        "argumentsConfiguration": [
          {
            "name": "month",
            "sourceType": "FIELD_ARGUMENT"
          },
          {
            "name": "year",
            "sourceType": "FIELD_ARGUMENT"
          }
        ]
      }
    ],
    "graphqlSchema": "schema {\n  query: Query\n  mutation: Mutation\n  subscription: Subscription\n}\n\ndirective @tag(name: String!) repeatable on ARGUMENT_DEFINITION | ENUM | ENUM_VALUE | FIELD_DEFINITION | INPUT_FIELD_DEFINITION | INPUT_OBJECT | INTERFACE | OBJECT | SCALAR | UNION\n\ntype ChargeCode {\n  code: String!\n  description: String\n  expired: Boolean!\n  group: String\n  id: ID!\n  name: String!\n  sortOrder: Int\n}\n\ntype Mutation {\n  createChargeCode(code: String!, description: String, expired: Boolean = false, group: String, name: String!, sortOrder: Int): ChargeCode\n  createQuickAction(chargeCodeIds: [ID!], description: String, name: String!, timeSlots: [Int!]): QuickAction!\n  createTrackedDay(date: Float!, mode: String): TrackedDay\n  createTrackedTask(chargeCodeIds: [ID!], notes: String, timeSlots: [Int!], trackedDayId: ID!): TrackedTask!\n  createUser(password: String!, username: String!): User\n  deleteChargeCode(id: ID!): ID\n  deleteQuickAction(id: ID!): ID\n  deleteTrackedDay(id: ID!): ID\n  deleteTrackedTask(id: ID): ID\n  deleteUser(username: String!): ID\n  updateChargeCode(code: String, description: String, expired: Boolean, group: String, id: ID!, name: String, sortOrder: Int): ChargeCode\n  updateQuickAction(chargeCodeIds: [ID!], description: String, id: ID!, name: String, timeSlots: [Int!]): QuickAction!\n  updateTrackedDay(id: ID!, mode: DayMode, trackedTaskIds: [String!]): TrackedDay\n  updateTrackedTask(chargeCodeIds: [ID!], id: ID!, notes: String, timeSlots: [Int!]): TrackedTask!\n  updateUser(trackedDayIds: [String], userId: ID!): User\n}\n\ntype PageInfo {\n  endCursor: String\n  hasNextPage: Boolean!\n  hasPreviousPage: Boolean!\n  startCursor: String\n}\n\ntype Query {\n  chargeCodes(code: String, description: String, expired: Boolean, ids: [ID!], name: String): [ChargeCode!]\n  quickAction(id: ID!): QuickAction\n  quickActions(ids: [ID!]): [QuickAction!]\n  timeChargeTotals(weekOfYear: WeekOfYear): [TimeChargeTotal!]\n  timeCharges(chargeCodeId: ID, timeSlot: Int, trackedDayId: String): [TimeCharge!]\n  trackedDay(id: ID): TrackedDay\n  trackedDaysForMonthYear(month: Int, year: Int): [TrackedDay!]\n  trackedDaysPaginated(after: String, first: Int): TrackedDayConnection\n  trackedTask(trackedTaskId: ID!): TrackedTask\n  trackedTasks(trackedDayId: ID): [TrackedTask!]\n  users(username: String): [User!]\n}\n\ntype QuickAction {\n  chargeCodes: [ChargeCode!]\n  description: String\n  id: ID!\n  name: String!\n  timeSlots: [Int!]\n}\n\ntype Subscription {\n  timeChargeTotalsChanged: TimeChargeTotal\n  trackedDayChanged(month: Int, year: Int): TrackedDay\n}\n\n\"\"\"\nupdateTimeCharge(\nid: ID!,\nchargeCodeAppearance: Int,\ntotalChargeCodesForSlot: Int\n): TimeCharge!\n}\n\"\"\"\ntype TimeCharge {\n  chargeCode: ChargeCode\n  \"\"\"The number of times this charge code appears at this timeslot\"\"\"\n  chargeCodeAppearance: Int\n  id: ID!\n  timeSlot: Int\n  \"\"\"\n  The number of chargecodes that appear across all tracked tasks at this timeslot\n  \"\"\"\n  totalChargeCodesForSlot: Int\n  trackedDay: TrackedDay\n}\n\n\"\"\"\nThis represents a single ChargeCode for a Tracked Day and the value for the timesheet\n\"\"\"\ntype TimeChargeTotal {\n  chargeCode: ChargeCode\n  id: ID!\n  trackedDay: TrackedDay\n  user: User\n  value: Float\n}\n\n\"\"\" each tracked day will have a max of 240 timeslots (if you work 24hrs!)\n\"\"\"\ntype TrackedDay {\n  date: Float!\n  id: ID!\n  mode: DayMode!\n  timeChargeTotals: [TimeChargeTotal!]\n  timeCharges: [TimeCharge!]\n  trackedTasks: [TrackedTask!]\n  user: User\n  week: Int!\n  year: Int!\n}\n\n\"\"\"\nthe @connection directive is meant to work but it clashes with dgs-codegen plugin (not supported yet, but there's\nan untouched PR...). For now, implementing the types manually here\n\"\"\"\ntype TrackedDayConnection {\n  edges: [TrackedDayEdge!]\n  pageInfo: PageInfo!\n}\n\ntype TrackedDayEdge {\n  cursor: String!\n  node: TrackedDay\n}\n\ntype TrackedTask {\n  chargeCodes: [ChargeCode!]\n  id: ID!\n  notes: String\n  timeSlots: [Int!]\n  trackedDay: TrackedDay\n}\n\ntype User {\n  id: ID!\n  trackedDays: [TrackedDay!]\n  username: String!\n}\n\nenum DayMode {\n  HOL_ANNUAL\n  HOL_PERSONAL\n  HOL_PUBLIC\n  HOL_RDO\n  NORMAL\n}\n\nenum ErrorDetail {\n  \"\"\"\n  The deadline expired before the operation could complete.\n  \n  For operations that change the state of the system, this error\n  may be returned even if the operation has completed successfully.\n  For example, a successful response from a server could have been\n  delayed long enough for the deadline to expire.\n  \n  HTTP Mapping: 504 Gateway Timeout\n  Error Type: UNAVAILABLE\n  \"\"\"\n  DEADLINE_EXCEEDED\n  \"\"\"\n  The server detected that the client is exhibiting a behavior that\n  might be generating excessive load.\n  \n  HTTP Mapping: 429 Too Many Requests or 420 Enhance Your Calm\n  Error Type: UNAVAILABLE\n  \"\"\"\n  ENHANCE_YOUR_CALM\n  \"\"\"\n  The requested field is not found in the schema.\n  \n  This differs from `NOT_FOUND` in that `NOT_FOUND` should be used when a\n  query is valid, but is unable to return a result (if, for example, a\n  specific video id doesn't exist). `FIELD_NOT_FOUND` is intended to be\n  returned by the server to signify that the requested field is not known to exist.\n  This may be returned in lieu of failing the entire query.\n  See also `PERMISSION_DENIED` for cases where the\n  requested field is invalid only for the given user or class of users.\n  \n  HTTP Mapping: 404 Not Found\n  Error Type: BAD_REQUEST\n  \"\"\"\n  FIELD_NOT_FOUND\n  \"\"\"\n  The client specified an invalid argument.\n  \n  Note that this differs from `FAILED_PRECONDITION`.\n  `INVALID_ARGUMENT` indicates arguments that are problematic\n  regardless of the state of the system (e.g., a malformed file name).\n  \n  HTTP Mapping: 400 Bad Request\n  Error Type: BAD_REQUEST\n  \"\"\"\n  INVALID_ARGUMENT\n  \"\"\"\n  The provided cursor is not valid.\n  \n  The most common usage for this error is when a client is paginating\n  through a list that uses stateful cursors. In that case, the provided\n  cursor may be expired.\n  \n  HTTP Mapping: 404 Not Found\n  Error Type: NOT_FOUND\n  \"\"\"\n  INVALID_CURSOR\n  \"\"\"\n  Unable to perform operation because a required resource is missing.\n  \n  Example: Client is attempting to refresh a list, but the specified\n  list is expired. This requires an action by the client to get a new list.\n  \n  If the user is simply trying GET a resource that is not found,\n  use the NOT_FOUND error type. FAILED_PRECONDITION.MISSING_RESOURCE\n  is to be used particularly when the user is performing an operation\n  that requires a particular resource to exist.\n  \n  HTTP Mapping: 400 Bad Request or 500 Internal Server Error\n  Error Type: FAILED_PRECONDITION\n  \"\"\"\n  MISSING_RESOURCE\n  \"\"\"\n  Service Error.\n  \n  There is a problem with an upstream service.\n  \n  This may be returned if a gateway receives an unknown error from a service\n  or if a service is unreachable.\n  If a request times out which waiting on a response from a service,\n  `DEADLINE_EXCEEDED` may be returned instead.\n  If a service returns a more specific error Type, the specific error Type may\n  be returned instead.\n  \n  HTTP Mapping: 502 Bad Gateway\n  Error Type: UNAVAILABLE\n  \"\"\"\n  SERVICE_ERROR\n  \"\"\"\n  Request failed due to network errors.\n  \n  HTTP Mapping: 503 Unavailable\n  Error Type: UNAVAILABLE\n  \"\"\"\n  TCP_FAILURE\n  \"\"\"\n  Request throttled based on server concurrency limits.\n  \n  HTTP Mapping: 503 Unavailable\n  Error Type: UNAVAILABLE\n  \"\"\"\n  THROTTLED_CONCURRENCY\n  \"\"\"\n  Request throttled based on server CPU limits\n  \n  HTTP Mapping: 503 Unavailable.\n  Error Type: UNAVAILABLE\n  \"\"\"\n  THROTTLED_CPU\n  \"\"\"\n  The operation is not implemented or is not currently supported/enabled.\n  \n  HTTP Mapping: 501 Not Implemented\n  Error Type: BAD_REQUEST\n  \"\"\"\n  UNIMPLEMENTED\n  \"\"\"\n  Unknown error.\n  \n  This error should only be returned when no other error detail applies.\n  If a client sees an unknown errorDetail, it will be interpreted as UNKNOWN.\n  \n  HTTP Mapping: 500 Internal Server Error\n  \"\"\"\n  UNKNOWN\n}\n\nenum ErrorType {\n  \"\"\"\n  Bad Request.\n  \n  There is a problem with the request.\n  Retrying the same request is not likely to succeed.\n  An example would be a query or argument that cannot be deserialized.\n  \n  HTTP Mapping: 400 Bad Request\n  \"\"\"\n  BAD_REQUEST\n  \"\"\"\n  The operation was rejected because the system is not in a state\n  required for the operation's execution.  For example, the directory\n  to be deleted is non-empty, an rmdir operation is applied to\n  a non-directory, etc.\n  \n  Service implementers can use the following guidelines to decide\n  between `FAILED_PRECONDITION` and `UNAVAILABLE`:\n  \n  - Use `UNAVAILABLE` if the client can retry just the failing call.\n  - Use `FAILED_PRECONDITION` if the client should not retry until\n  the system state has been explicitly fixed.  E.g., if an \"rmdir\"\n  fails because the directory is non-empty, `FAILED_PRECONDITION`\n  should be returned since the client should not retry unless\n  the files are deleted from the directory.\n  \n  HTTP Mapping: 400 Bad Request or 500 Internal Server Error\n  \"\"\"\n  FAILED_PRECONDITION\n  \"\"\"\n  Internal error.\n  \n  An unexpected internal error was encountered. This means that some\n  invariants expected by the underlying system have been broken.\n  This error code is reserved for serious errors.\n  \n  HTTP Mapping: 500 Internal Server Error\n  \"\"\"\n  INTERNAL\n  \"\"\"\n  The requested entity was not found.\n  \n  This could apply to a resource that has never existed (e.g. bad resource id),\n  or a resource that no longer exists (e.g. cache expired.)\n  \n  Note to server developers: if a request is denied for an entire class\n  of users, such as gradual feature rollout or undocumented allowlist,\n  `NOT_FOUND` may be used. If a request is denied for some users within\n  a class of users, such as user-based access control, `PERMISSION_DENIED`\n  must be used.\n  \n  HTTP Mapping: 404 Not Found\n  \"\"\"\n  NOT_FOUND\n  \"\"\"\n  The caller does not have permission to execute the specified\n  operation.\n  \n  `PERMISSION_DENIED` must not be used for rejections\n  caused by exhausting some resource or quota.\n  `PERMISSION_DENIED` must not be used if the caller\n  cannot be identified (use `UNAUTHENTICATED`\n  instead for those errors).\n  \n  This error Type does not imply the\n  request is valid or the requested entity exists or satisfies\n  other pre-conditions.\n  \n  HTTP Mapping: 403 Forbidden\n  \"\"\"\n  PERMISSION_DENIED\n  \"\"\"\n  The request does not have valid authentication credentials.\n  \n  This is intended to be returned only for routes that require\n  authentication.\n  \n  HTTP Mapping: 401 Unauthorized\n  \"\"\"\n  UNAUTHENTICATED\n  \"\"\"\n  Currently Unavailable.\n  \n  The service is currently unavailable.  This is most likely a\n  transient condition, which can be corrected by retrying with\n  a backoff.\n  \n  HTTP Mapping: 503 Unavailable\n  \"\"\"\n  UNAVAILABLE\n  \"\"\"\n  Unknown error.\n  \n  For example, this error may be returned when\n  an error code received from another address space belongs to\n  an error space that is not known in this address space.  Also\n  errors raised by APIs that do not return enough error information\n  may be converted to this error.\n  \n  If a client sees an unknown errorType, it will be interpreted as UNKNOWN.\n  Unknown errors MUST NOT trigger any special behavior. These MAY be treated\n  by an implementation as being equivalent to INTERNAL.\n  \n  When possible, a more specific error should be provided.\n  \n  HTTP Mapping: 520 Unknown Error\n  \"\"\"\n  UNKNOWN\n}\n\ninput WeekOfYear {\n  week: Int\n  year: Int!\n}",
    "stringStorage": {
      "ea41d894b5b56061991f524eb9061a0139c0f700": "schema {\n  query: Query\n  mutation: Mutation\n  subscription: Subscription\n}\n\ndirective @extends on INTERFACE | OBJECT\n\ndirective @external on FIELD_DEFINITION | OBJECT\n\ndirective @key(fields: openfed__FieldSet!, resolvable: Boolean = true) repeatable on INTERFACE | OBJECT\n\ndirective @provides(fields: openfed__FieldSet!) on FIELD_DEFINITION\n\ndirective @requires(fields: openfed__FieldSet!) on FIELD_DEFINITION\n\ndirective @tag(name: String!) repeatable on ARGUMENT_DEFINITION | ENUM | ENUM_VALUE | FIELD_DEFINITION | INPUT_FIELD_DEFINITION | INPUT_OBJECT | INTERFACE | OBJECT | SCALAR | UNION\n\ntype ChargeCode {\n  code: String!\n  description: String\n  expired: Boolean!\n  group: String\n  id: ID!\n  name: String!\n  sortOrder: Int\n}\n\nenum DayMode {\n  HOL_ANNUAL\n  HOL_PERSONAL\n  HOL_PUBLIC\n  HOL_RDO\n  NORMAL\n}\n\nenum ErrorDetail {\n  \"\"\"\n  The deadline expired before the operation could complete.\n  \n  For operations that change the state of the system, this error\n  may be returned even if the operation has completed successfully.\n  For example, a successful response from a server could have been\n  delayed long enough for the deadline to expire.\n  \n  HTTP Mapping: 504 Gateway Timeout\n  Error Type: UNAVAILABLE\n  \"\"\"\n  DEADLINE_EXCEEDED\n  \"\"\"\n  The server detected that the client is exhibiting a behavior that\n  might be generating excessive load.\n  \n  HTTP Mapping: 429 Too Many Requests or 420 Enhance Your Calm\n  Error Type: UNAVAILABLE\n  \"\"\"\n  ENHANCE_YOUR_CALM\n  \"\"\"\n  The requested field is not found in the schema.\n  \n  This differs from `NOT_FOUND` in that `NOT_FOUND` should be used when a\n  query is valid, but is unable to return a result (if, for example, a\n  specific video id doesn't exist). `FIELD_NOT_FOUND` is intended to be\n  returned by the server to signify that the requested field is not known to exist.\n  This may be returned in lieu of failing the entire query.\n  See also `PERMISSION_DENIED` for cases where the\n  requested field is invalid only for the given user or class of users.\n  \n  HTTP Mapping: 404 Not Found\n  Error Type: BAD_REQUEST\n  \"\"\"\n  FIELD_NOT_FOUND\n  \"\"\"\n  The client specified an invalid argument.\n  \n  Note that this differs from `FAILED_PRECONDITION`.\n  `INVALID_ARGUMENT` indicates arguments that are problematic\n  regardless of the state of the system (e.g., a malformed file name).\n  \n  HTTP Mapping: 400 Bad Request\n  Error Type: BAD_REQUEST\n  \"\"\"\n  INVALID_ARGUMENT\n  \"\"\"\n  The provided cursor is not valid.\n  \n  The most common usage for this error is when a client is paginating\n  through a list that uses stateful cursors. In that case, the provided\n  cursor may be expired.\n  \n  HTTP Mapping: 404 Not Found\n  Error Type: NOT_FOUND\n  \"\"\"\n  INVALID_CURSOR\n  \"\"\"\n  Unable to perform operation because a required resource is missing.\n  \n  Example: Client is attempting to refresh a list, but the specified\n  list is expired. This requires an action by the client to get a new list.\n  \n  If the user is simply trying GET a resource that is not found,\n  use the NOT_FOUND error type. FAILED_PRECONDITION.MISSING_RESOURCE\n  is to be used particularly when the user is performing an operation\n  that requires a particular resource to exist.\n  \n  HTTP Mapping: 400 Bad Request or 500 Internal Server Error\n  Error Type: FAILED_PRECONDITION\n  \"\"\"\n  MISSING_RESOURCE\n  \"\"\"\n  Service Error.\n  \n  There is a problem with an upstream service.\n  \n  This may be returned if a gateway receives an unknown error from a service\n  or if a service is unreachable.\n  If a request times out which waiting on a response from a service,\n  `DEADLINE_EXCEEDED` may be returned instead.\n  If a service returns a more specific error Type, the specific error Type may\n  be returned instead.\n  \n  HTTP Mapping: 502 Bad Gateway\n  Error Type: UNAVAILABLE\n  \"\"\"\n  SERVICE_ERROR\n  \"\"\"\n  Request failed due to network errors.\n  \n  HTTP Mapping: 503 Unavailable\n  Error Type: UNAVAILABLE\n  \"\"\"\n  TCP_FAILURE\n  \"\"\"\n  Request throttled based on server concurrency limits.\n  \n  HTTP Mapping: 503 Unavailable\n  Error Type: UNAVAILABLE\n  \"\"\"\n  THROTTLED_CONCURRENCY\n  \"\"\"\n  Request throttled based on server CPU limits\n  \n  HTTP Mapping: 503 Unavailable.\n  Error Type: UNAVAILABLE\n  \"\"\"\n  THROTTLED_CPU\n  \"\"\"\n  The operation is not implemented or is not currently supported/enabled.\n  \n  HTTP Mapping: 501 Not Implemented\n  Error Type: BAD_REQUEST\n  \"\"\"\n  UNIMPLEMENTED\n  \"\"\"\n  Unknown error.\n  \n  This error should only be returned when no other error detail applies.\n  If a client sees an unknown errorDetail, it will be interpreted as UNKNOWN.\n  \n  HTTP Mapping: 500 Internal Server Error\n  \"\"\"\n  UNKNOWN\n}\n\nenum ErrorType {\n  \"\"\"\n  Bad Request.\n  \n  There is a problem with the request.\n  Retrying the same request is not likely to succeed.\n  An example would be a query or argument that cannot be deserialized.\n  \n  HTTP Mapping: 400 Bad Request\n  \"\"\"\n  BAD_REQUEST\n  \"\"\"\n  The operation was rejected because the system is not in a state\n  required for the operation's execution.  For example, the directory\n  to be deleted is non-empty, an rmdir operation is applied to\n  a non-directory, etc.\n  \n  Service implementers can use the following guidelines to decide\n  between `FAILED_PRECONDITION` and `UNAVAILABLE`:\n  \n  - Use `UNAVAILABLE` if the client can retry just the failing call.\n  - Use `FAILED_PRECONDITION` if the client should not retry until\n  the system state has been explicitly fixed.  E.g., if an \"rmdir\"\n  fails because the directory is non-empty, `FAILED_PRECONDITION`\n  should be returned since the client should not retry unless\n  the files are deleted from the directory.\n  \n  HTTP Mapping: 400 Bad Request or 500 Internal Server Error\n  \"\"\"\n  FAILED_PRECONDITION\n  \"\"\"\n  Internal error.\n  \n  An unexpected internal error was encountered. This means that some\n  invariants expected by the underlying system have been broken.\n  This error code is reserved for serious errors.\n  \n  HTTP Mapping: 500 Internal Server Error\n  \"\"\"\n  INTERNAL\n  \"\"\"\n  The requested entity was not found.\n  \n  This could apply to a resource that has never existed (e.g. bad resource id),\n  or a resource that no longer exists (e.g. cache expired.)\n  \n  Note to server developers: if a request is denied for an entire class\n  of users, such as gradual feature rollout or undocumented allowlist,\n  `NOT_FOUND` may be used. If a request is denied for some users within\n  a class of users, such as user-based access control, `PERMISSION_DENIED`\n  must be used.\n  \n  HTTP Mapping: 404 Not Found\n  \"\"\"\n  NOT_FOUND\n  \"\"\"\n  The caller does not have permission to execute the specified\n  operation.\n  \n  `PERMISSION_DENIED` must not be used for rejections\n  caused by exhausting some resource or quota.\n  `PERMISSION_DENIED` must not be used if the caller\n  cannot be identified (use `UNAUTHENTICATED`\n  instead for those errors).\n  \n  This error Type does not imply the\n  request is valid or the requested entity exists or satisfies\n  other pre-conditions.\n  \n  HTTP Mapping: 403 Forbidden\n  \"\"\"\n  PERMISSION_DENIED\n  \"\"\"\n  The request does not have valid authentication credentials.\n  \n  This is intended to be returned only for routes that require\n  authentication.\n  \n  HTTP Mapping: 401 Unauthorized\n  \"\"\"\n  UNAUTHENTICATED\n  \"\"\"\n  Currently Unavailable.\n  \n  The service is currently unavailable.  This is most likely a\n  transient condition, which can be corrected by retrying with\n  a backoff.\n  \n  HTTP Mapping: 503 Unavailable\n  \"\"\"\n  UNAVAILABLE\n  \"\"\"\n  Unknown error.\n  \n  For example, this error may be returned when\n  an error code received from another address space belongs to\n  an error space that is not known in this address space.  Also\n  errors raised by APIs that do not return enough error information\n  may be converted to this error.\n  \n  If a client sees an unknown errorType, it will be interpreted as UNKNOWN.\n  Unknown errors MUST NOT trigger any special behavior. These MAY be treated\n  by an implementation as being equivalent to INTERNAL.\n  \n  When possible, a more specific error should be provided.\n  \n  HTTP Mapping: 520 Unknown Error\n  \"\"\"\n  UNKNOWN\n}\n\ntype Mutation {\n  createChargeCode(code: String!, description: String, expired: Boolean = false, group: String, name: String!, sortOrder: Int): ChargeCode\n  createQuickAction(chargeCodeIds: [ID!], description: String, name: String!, timeSlots: [Int!]): QuickAction!\n  createTrackedDay(date: Float!, mode: String): TrackedDay\n  createTrackedTask(chargeCodeIds: [ID!], notes: String, timeSlots: [Int!], trackedDayId: ID!): TrackedTask!\n  createUser(password: String!, username: String!): User\n  deleteChargeCode(id: ID!): ID\n  deleteQuickAction(id: ID!): ID\n  deleteTrackedDay(id: ID!): ID\n  deleteTrackedTask(id: ID): ID\n  deleteUser(username: String!): ID\n  updateChargeCode(code: String, description: String, expired: Boolean, group: String, id: ID!, name: String, sortOrder: Int): ChargeCode\n  updateQuickAction(chargeCodeIds: [ID!], description: String, id: ID!, name: String, timeSlots: [Int!]): QuickAction!\n  updateTrackedDay(id: ID!, mode: DayMode, trackedTaskIds: [String!]): TrackedDay\n  updateTrackedTask(chargeCodeIds: [ID!], id: ID!, notes: String, timeSlots: [Int!]): TrackedTask!\n  updateUser(trackedDayIds: [String], userId: ID!): User\n}\n\ntype PageInfo {\n  endCursor: String\n  hasNextPage: Boolean!\n  hasPreviousPage: Boolean!\n  startCursor: String\n}\n\ntype Query {\n  chargeCodes(code: String, description: String, expired: Boolean, ids: [ID!], name: String): [ChargeCode!]\n  quickAction(id: ID!): QuickAction\n  quickActions(ids: [ID!]): [QuickAction!]\n  timeChargeTotals(weekOfYear: WeekOfYear): [TimeChargeTotal!]\n  timeCharges(chargeCodeId: ID, timeSlot: Int, trackedDayId: String): [TimeCharge!]\n  trackedDay(id: ID): TrackedDay\n  trackedDaysForMonthYear(month: Int, year: Int): [TrackedDay!]\n  trackedDaysPaginated(after: String, first: Int): TrackedDayConnection\n  trackedTask(trackedTaskId: ID!): TrackedTask\n  trackedTasks(trackedDayId: ID): [TrackedTask!]\n  users(username: String): [User!]\n}\n\ntype QuickAction {\n  chargeCodes: [ChargeCode!]\n  description: String\n  id: ID!\n  name: String!\n  timeSlots: [Int!]\n}\n\ntype Subscription {\n  timeChargeTotalsChanged: TimeChargeTotal\n  trackedDayChanged(month: Int, year: Int): TrackedDay\n}\n\n\"\"\"\nupdateTimeCharge(\nid: ID!,\nchargeCodeAppearance: Int,\ntotalChargeCodesForSlot: Int\n): TimeCharge!\n}\n\"\"\"\ntype TimeCharge {\n  chargeCode: ChargeCode\n  \"\"\"The number of times this charge code appears at this timeslot\"\"\"\n  chargeCodeAppearance: Int\n  id: ID!\n  timeSlot: Int\n  \"\"\"\n  The number of chargecodes that appear across all tracked tasks at this timeslot\n  \"\"\"\n  totalChargeCodesForSlot: Int\n  trackedDay: TrackedDay\n}\n\n\"\"\"\nThis represents a single ChargeCode for a Tracked Day and the value for the timesheet\n\"\"\"\ntype TimeChargeTotal {\n  chargeCode: ChargeCode\n  id: ID!\n  trackedDay: TrackedDay\n  user: User\n  value: Float\n}\n\n\"\"\" each tracked day will have a max of 240 timeslots (if you work 24hrs!)\n\"\"\"\ntype TrackedDay {\n  date: Float!\n  id: ID!\n  mode: DayMode!\n  timeChargeTotals: [TimeChargeTotal!]\n  timeCharges: [TimeCharge!]\n  trackedTasks: [TrackedTask!]\n  user: User\n  week: Int!\n  year: Int!\n}\n\n\"\"\"\nthe @connection directive is meant to work but it clashes with dgs-codegen plugin (not supported yet, but there's\nan untouched PR...). For now, implementing the types manually here\n\"\"\"\ntype TrackedDayConnection {\n  edges: [TrackedDayEdge!]\n  pageInfo: PageInfo!\n}\n\ntype TrackedDayEdge {\n  cursor: String!\n  node: TrackedDay\n}\n\ntype TrackedTask {\n  chargeCodes: [ChargeCode!]\n  id: ID!\n  notes: String\n  timeSlots: [Int!]\n  trackedDay: TrackedDay\n}\n\ntype User {\n  id: ID!\n  trackedDays: [TrackedDay!]\n  username: String!\n}\n\ninput WeekOfYear {\n  week: Int\n  year: Int!\n}\n\nscalar openfed__FieldSet"
    }
  },
  "version": "dbcfc148-91c8-4027-b2bf-ffad6ce7a29c",
  "subgraphs": [
    {
      "id": "0",
      "name": "jikan-ga-aru",
      "routingUrl": "http://localhost/graphql"
    }
  ]
}